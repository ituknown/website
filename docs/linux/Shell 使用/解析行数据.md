比如有 csv 中有如下数据：

```csv
order_id,user_id
23329989527,610049527
23330159862,502629862
23330595420,610205420
23330655420,610205420
...
```

我需要实现的功能是：

```bash
curl \
-X POST \
-H "Content-Type: application/json" \
-d '{"command": "ALL", "orderId": $order_id, "userId"： $user_id}' \
"https://domain/api/.."
```

就是将 csv 中的行数据解析出来填充到该 curl 命令参数中。

解决方式也很简单，可以使用 `while read` 来实现，示例：

```bash
cat order.csv | while IFS=, read -r order_id user_id; do
    echo "order_id=$order_id, user_id=$user_id"
done
```

`IFS` 是 Internal Field Separator（内部字段分隔符）的缩写，可以用来实现“怎么把一行文本拆分成多个字段”。

默认情况下，`IFS` 值是：

```
<空格><制表符><换行符>
```

也就是说，shell 在处理诸如 `read`、`for`、`set` 等命令时，会把空格、Tab 和换行当作分隔符。因为该 csv 中每行之间的内容使用的是 `,` 分隔字符，所以需要明确指定 `IFS=,`。

至于 `read` 命令则用于实现将读取的内容按顺序赋值给指定的变量。示例：

```bash
line="apple banana cherry"
read a b c <<< "$line"
echo "$a | $b | $c" // 输出: apple | banana | cherry
```

因为 line 中的字符使用的是空格分隔，所以 read 会自动分隔字符并赋值给 a、b、c。

再比如如果只使用两个变量接收：

```bash
line="apple banana cherry"
read a b <<< "$line"
echo "$a | $b" // 输出: apple | banana cherry
```

再比如下面的示例：

```bash
line="apple banana|cherry"
read a b <<< "$line"
echo "$a | $b" // 输出: apple | banana|cherry
```

如果想输出的是 `apple | banana|cherry` 则需要使用 IFS 指定分隔符：

```bash
line="apple banana|cherry"
IFS=| read a b <<< "$line"
echo "$a | $b" // 输出: apple | banana|cherry
```

所以只需要使用 `while read` 就能很轻松的实现 curl 填充参数需求：

```bash
cat order.csv | while IFS=, read order_id user_id; do
    curl \
    -X POST \
    -H "Content-Type: application/json" \
    -d "{\"command\":\"ALL\",\"orderId\":$order_id,\"userId\":$user_id}" \
    "http://localhost:9120/api/syncOrder"
done
```

或使用管道配合 `xargs -P` 并行执行：

```bash
cat order.csv | while IFS=, read -r orderId userId; do
    echo "curl -X POST \
    -H \"Content-Type: application/json\" \
    -d {\"command\":\"ALL\",\"orderId\":$order_id,\"userId\":$user_id} \
    http://localhost:9120/api/syncOrder"
done | xargs -I {} -P 5 bash -c "{}"
```